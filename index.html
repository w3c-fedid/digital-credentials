<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Digital Credentials
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class=
    "remove"></script>
    <script class="remove">
    "use strict";
    // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
    var respecConfig = {
      github: "w3c-fedid/digital-credentials",
      editors: [
        {
          name: "Marcos Caceres",
          email: "marcosc@apple.com",
          company: "Apple Inc.",
          companyURL: "https://apple.com",
          w3cid: 39125,
        },
        {
          name: "Tim Cappalli",
          email: "tim.cappalli@okta.com",
          company: "Okta",
          companyURL: "https://okta.com",
          w3cid: 111190,
        },
        {
          name: "Mohamed Amir Yosef",
          email: "mamir@google.com",
          company: "Google Inc.",
          companyURL: "https://google.com",
          w3cid: 158857,
        },
        {
          name: "Sam Goto",
          email: "goto@google.com",
          company: "Google Inc.",
          companyURL: "https://google.com",
          retiredDate: "2025-05-02",
          w3cid: 50308,
        },
        // Add additional editors here.
        // https://github.com/w3c/respec/wiki/editors
      ],
      shortName: "digital-credentials",
      specStatus: "ED",
      edDraftURI: "https://w3c-fedid.github.io/digital-credentials/",
      group: "fedid",
      github: "https://github.com/w3c-fedid/digital-credentials",
      localBiblio: {
        "credential-considerations": {
          title: "User considerations for credentials on the Web",
          href: "https://github.com/w3c/credential-considerations/blob/main/credentials-considerations.md",
          authors: ["Nick Doty", "Rick Byers"],
          date: "2025-03-26",
          publisher: "W3C"
        },
        "threat-model-decentralized-identities": {
          title: "Threat Model for Decentralized Identities",
          href: "https://github.com/w3c-cg/threat-modeling/blob/main/models/decentralized-identities.md",
          authors: ["Simone Onofri"],
          date: "2025-05-28",
          publisher: "W3C"
        },
        "custom-schemes": {
          title: "Concerns with custom schemes for identity presentment",
          href: "https://github.com/w3c-fedid/digital-credentials/blob/main/custom-schemes.md",
          authors: ["Rick Byers"],
          date: "2024-05-01",
          publisher: "W3C"
        },
        "presenting-credentials-on-the-web": {
          title: "Presenting Credentials on the Web",
          href: "https://docs.google.com/document/d/1Ppaz_EnhzHqPOz5UusRJvbSunh-RXPWgJ3Np_TM2EE0/",
          authors: ["Simone Onofri"]
        },
        "identity-web-impact": {
          title: "Identity & the Web",
          href: "https://www.w3.org/reports/identity-web-impact",
          authors: ["Simone Onofri"],
          date: "2025-02-25",
          publisher: "W3C"
        },
      },
      xref: {
        profile: "web-platform",
      },
    };
    </script>
  </head>
  <body data-cite="credential-management vc-data-model">
    <section id="abstract">
      <p>
        This document specifies an API to enable [=user agents=] to mediate
        presentation and issuance of digital credentials such as a driver's
        license, government-issued identification card, and/or [=credential
        type examples|other types of digital credential=]. The API builds on
        [[[credential-management]]] as a means by which to request or issue a
        digital credential from a user agent or underlying platform.
      </p>
    </section>
    <section id="sotd"></section><!--
    // MARK: Introduction
    -->
    <h2 class="informative">
      Introduction
    </h2>
    <p>
      This document defines an API enabling a website to request presentation
      and issuance of a [=digital credential=].
    </p>
    <p>
      The API design is agnostic to credential formats and includes support for
      multiple [=digital credential/presentation protocols=] and [=digital
      credential/issuance protocols=]. See [[[#protocols]]].
    </p>
    <p>
      The API is designed to support the following goals:
    </p>
    <ul>
      <li>Keep the acts of [=digital credential/presentation
      requests|requesting=] and [=digital credential/issuance
      requests|issuing=] separate from the specific [=digital
      credential/presentation protocol=] and [=digital credential/issuance
      protocol=] respectively; thereby enabling the extensibility of such
      protocols and credential formats.
      </li>
      <li>Require [=digital credential/presentation requests=] and [=digital
      credential/issuance requests=] to be unencrypted, enabling user-agent
      inspection for risk analysis.
      </li>
      <li>Assume opaque (i.e., encrypted) [=digital credential/presentation
      responses=] and [=digital credential/issuance responses=], enabling
      issuers, verifiers, and holders to control where potentially sensitive
      personally identifiable information is exposed.
      </li>
      <li>Require [=transient activation=] to perform [=digital
      credential/presentation requests=] or [=digital credential/issuance
      requests=], ensuring that sites cannot silently query for nor issue
      digital credentials, nor communicate with wallet providers, without the
      user's active participation and confirmation of each action.
      </li>
      <li>Enable platform-provided credential selection UX when multiple wallet
      applications have credentials that match a [=digital
      credential/presentation request=].
      </li>
      <li>Enable platform-provided wallet selection UX when multiple wallet
      applications support an [=digital credential/issuance request=].
      </li>
      <li>Enable platforms to provide secure cross-device [=digital
      credential/presentation requests=] and [=digital credential/issuance
      requests=] with proximity checks.
      </li>
    </ul>
    <p id="credential-type-examples">
      [=Digital credentials=] of many types can be presented and issued using
      this API. <dfn data-lt="credential type examples">Examples of these
      types</dfn> include:
    </p>
    <ul>
      <li>a driving license, passport, or other identity card issued by a
      government institution
      </li>
      <li>a travel authorization document issued by an embassy or consulate
      </li>
      <li>a proof of employment issued by a public or private organization
      </li>
      <li>a proof of education or professional training issued by an
      institution
      </li>
      <li>and many other scenarios as described in <a href=
      "https://www.w3.org/TR/vc-use-cases/">Verifiable Credentials Use
      Cases</a>
      </li>
    </ul>
    <section class="informative">
      <!--
      // MARK: Examples of usage
      -->
      <h2>
        Examples of usage
      </h2>
      <p>
        The following examples illustrate how the Digital Credentials API can
        be used to request and issue digital credentials.
      </p>
      <h3>
        Feature Detection
      </h3>
      <p>
        Before using the Digital Credentials API, it's important to check if
        the user agent supports the necessary features. This can be done using
        the following code:
      </p>
      <pre class="example js" title="Checking for API support">
        if (typeof DigitalCredential !== "undefined") {
          // Digital Credentials API is supported
        } else {
          // Digital Credentials API is not supported
        }
      </pre>
      <h3>
        Checking if protocol is allowed
      </h3>
      <p>
        The {{DigitalCredential/userAgentAllowsProtocol()}} static method can
        be used to check if the user agent allows a specific protocol for
        digital credential issuance or presentation. This is useful for
        checking which protocols are allowed by the user's browsers prior to
        making an API call.
      </p>
      <pre class="example js" title=
      "Using the userAgentAllowsProtocol() static method">
        if (DigitalCredential.userAgentAllowsProtocol("example-protocol")) {
          // DC API supported. Proceed with issuance or presentation.
        } else {
          // DC API not supported. Fall back to, for example,
          // a traditional HTML form-based approach.
          showHTMLForm();
        }
      </pre>
      <p>
        Alternatively, one can check for support of multiple protocols,
        filtering out those that are not supported:
      </p>
      <pre class="example js" title=
      "Checking multiple protocols with userAgentAllowsProtocol()">
        const protocols = [
          "example-issuance-protocol",
          "another-issuance-protocol"
        ];
        const supportedProtocols = protocols.filter(DigitalCredential.userAgentAllowsProtocol);
        if (supportedProtocols.length &gt; 0) {
          // At least one protocol is supported. Proceed with issuance.
        } else {
          // No protocols are supported. Fall back to a different issuance method.
        }
      </pre>
      <h3>
        Requesting a digital credential
      </h3>
      <p>
        The following example shows how to request a digital credential using
        the Digital Credentials API. The entry point for the API is the
        `navigator.credentials.`{{CredentialsContainer/get()}} method, which is
        used to request a [=digital credential=] from the user agent. If the
        user agent supports [=digital credential/presentation
        requests|presentation=], it allows the user to select a digital
        credential through a [=credential chooser=]:
      </p>
      <pre class="example html" title="Requesting a digital credential">
        &lt;button&gt;Verify Identity&lt;/button&gt;
        &lt;script&gt;
          const button = document.querySelector("button");
          button.addEventListener("click", async () =&gt; {
            const protocol = "example-request-protocol";
            // Check for DC API and protocol support
            if (!DigitalCredential.userAgentAllowsProtocol(protocol)) {
              // The browser doesn't allow the use of this protocol.
              // Fall back to a different verification method.
              showTraditionalVerificationForm();
              return;
            }
            try {
              const credential = await navigator.credentials.get({
                digital: {
                  requests: [{
                    protocol,
                    data: { /* request data */ }
                  }]
                }
              });

              // Post it back to the verifier server for decryption and verification
              const response = await fetch("/verify-credential", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(credential)
              });

              // Check response
              if (!response.ok) {
                throw new Error("Failed to verify credential");
              }

              // Render the verification result
              displayVerificationResult(await response.json());

            } catch (error) {
              console.error("Error requesting digital credential:", error);
            }
          });
        &lt;/script&gt;
      </pre>
      <p>
        Similarly, when a site needs to [=digital credential/issuance|issue=] a
        digital credential, the Digital Credentials API mediates the issuance
        of a digital credential between the site, the user agent, and the
        [=holder=].
      </p>
      <h3>
        Issuing a digital credential
      </h3>
      <p>
        The following example shows how to request the issuance of a digital
        credential using the Digital Credentials API. To issue a digital
        credential, a site calls the
        `navigator.credentials.`{{CredentialsContainer/create()}} method,
        which, if the user agent supports issuance, would initiate the issuance
        flow:
      </p>
      <pre class="example html" title=
      "Requesting issuance of a digital credential">
        &lt;button&gt;Request Digital Credential Issuance&lt;/button&gt;
        &lt;script&gt;
          const button = document.querySelector("button");
          button.addEventListener("click", async () =&gt; {
            const protocol = "example-issuance-protocol";
            // Check for DC API and protocol support
            if (!DigitalCredential.userAgentAllowsProtocol(protocol)) {
              // The browser doesn't allow the use of this protocol.
              // Fall back to a different issuance method.
              showTraditionalIssuanceForm();
              return;
            }
            try {
              const credential = await navigator.credentials.create({
                digital: {
                  requests: [{
                    protocol,
                    data: { /* issuance request data */ }
                  }]
                }
              });
            } catch (error) {
              console.error("Error issuing digital credential:", error);
            }
          });
        &lt;/script&gt;
      </pre>
      <h3>
        Requesting a digital credential across origins
      </h3>
      <p>
        The specification allows usage of the API for presenting credentials
        from a remote/third-party origin via the
        <a>"digital-credentials-get"</a> Permissions Policy. This is useful for
        scenarios where a website wants to request digital credentials from a
        verification service that is hosted on a different origin. The
        Permissions Policy can be set on an iframe that embeds the website that
        wants to use the API. Here is an example of how the Permissions Policy
        can be set on an iframe:
      </p>
      <pre class="example html" title=
      "Requesting a digital credential across origins">
        &lt;iframe src="https://wallet-provider.example.com"
                allow="digital-credentials-get"&gt;
        &lt;/iframe&gt;
      </pre>
      <h3>
        Issuing a digital credential across origins
      </h3>
      <p>
        Similarly, the specification allows usage of the API for issuing
        credentials from a remote/third-party origin via the
        <a>"digital-credentials-create"</a> Permissions Policy. This is useful
        for scenarios where a website wants to request issuance of a digital
        credential using an issuance service on a different origin. The
        Permissions Policy can be set on an iframe embedding the issuer's
        interface. Here is an example:
      </p>
      <pre class="example html" title=
      "Issuing a digital credential across origins">
        &lt;iframe src="https://issuer.example.com"
                allow="digital-credentials-create"&gt;
        &lt;/iframe&gt;
      </pre>
    </section><!--
    // MARK: Scope
    -->
    <h2 class="informative">
      Scope
    </h2>
    <p>
      The following items are within the scope of this specification:
    </p>
    <ul>
      <li>[=digital credential/presentation|Presentation requests=] including
      mechanisms for [=digital credential/presentation|presentation=] of
      [=digital credentials=].
      </li>
      <li>[=digital credential/issuance|Issuance requests=] for [=digital
      credentials=].
      </li>
      <li>Mechanisms ensuring that, when an API call is made, the website does
      not learn anything about the [=holder=] nor any [=digital credentials=]
      they hold, without explicit user consent.
      </li>
      <li>Ensuring that any installed application software will not learn
      anything about a given [=digital credential/issuance request=] or
      [=digital credential/presentation request=] unless the [=holder=]
      explicitly consents to use that software.
      </li>
    </ul>
    <p>
      The following items are out of scope:
    </p>
    <ul>
      <li>UI/UX considerations, except for accessibility and privacy aspects,
      which are addressed to ensure access to and protection of user data
      during [=digital credential/presentation=] and [=digital
      credential/issuance=] processes.
      </li>
      <li>Functionality outside the [=user agent=] is out of scope, including
      platform-specific frameworks, native operating system APIs, standalone
      applications, and hardware components that store, manage, or process
      [=digital credentials=]. This includes the user interface and user
      interactions for selecting a specific credential and obtaining the user's
      permission to forward a request to the user-selected wallet.
      </li>
      <li>Implementation of credential managers, specifically in the role of
      [=holder=] software (commonly known as "digital wallets"), including how
      they securely store or manage [=digital credentials=] or advertise
      capabilities to [=digital credential/presentation|present=] or [=digital
      credential/issuance|issue=] them to the [=user agent=], is out of scope.
      The only exception is the transmission of [=digital credential/issuance
      request data=] and [=digital credential/request data|credential request
      data=] to and from such software.
      </li>
    </ul><!--
    // MARK: Model
    -->
    <h2>
      Model
    </h2>
    <p class="note" title="Definitions under discussion">
      The goal of the definitions in this section is to reuse or establish
      terminology that is common across a variety of digital credential formats
      and protocols. Discussions surrounding these definitions are active and
      the definitions are likely to change over the next several months.
    </p>
    <dl class="definitions" data-sort="" data-cite="vc-data-model">
      <dt>
        <dfn>Digital credential</dfn>
      </dt>
      <dd>
        A cryptographically signed digital document containing one or more
        [=claims=] made by an [=issuer=] about one or more [=subjects=].
        <p class="note" title="Focus on digital credentials about people">
          This specification is currently focused on digital credentials
          pertaining to people.
        </p>
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential" data-local-lt=
        "presentation">Presentation request</dfn>
      </dt>
      <dd>
        A presentation request is a request for a [=digital credential=]
        composed of [=digital credential/request data=] and a [=digital
        credential/presentation protocol=].
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential">Request data</dfn>
      </dt>
      <dd>
        A format that [=verifier=] software or a [=user agent=] uses, via an
        [=digital credential/presentation protocol=], to request a [=digital
        credential=] from a [=holder=].
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential" data-local-lt=
        "presentation response">Presentation response</dfn>
      </dt>
      <dd>
        A format that a [=holder's=] software, such as a digital wallet, uses,
        via an [=digital credential/presentation protocol=], to respond to a
        [=digital credential/presentation request=] by a [=verifier=].
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential" data-local-lt=
        "credential response">Credential response</dfn>
      </dt>
      <dd>
        A [=digital credential/presentation response=] or an [=digital
        credential/issuance response=].
      </dd>
      <dt>
        <dfn data-for="digital credential">Credential request</dfn>
      </dt>
      <dd>
        A [=digital credential/presentation request=] or an [=digital
        credential/issuance request=].
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential" data-local-lt=
        "issuance">Issuance request</dfn>
      </dt>
      <dd>
        An issuance request is a request to issue a [=digital credential=]
        composed of some [=digital credential/issuance request data=] and an
        [=digital credential/issuance protocol=].
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential">Issuance request data</dfn>
      </dt>
      <dd>
        A data structure that an [=issuer=] or a [=user agent=], via an
        [=digital credential/issuance protocol=], to request the issuance of a
        [=digital credential=] by an [=issuer=].
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential">Issuance response</dfn>
      </dt>
      <dd>
        A format that [=holder=] uses, via an [=digital credential/issuance
        protocol=], to respond to an [=digital credential/issuance request=] by
        an [=issuer=].
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential" data-local-lt=
        "presentation protocol">Presentation protocol</dfn>
      </dt>
      <dd>
        A standardized protocol used for presenting a [=digital credential=]
        between a [=holder=] and a [=verifier=]. A protocol is identified by a
        [=digital credential/protocol identifier=]. See [[[#protocols]]].
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential">Protocol identifier</dfn>
      </dt>
      <dd>
        A [=string=] composed of one or more [=ASCII lower alpha=] [=code
        points=], zero or more U+002D HYPHEN-MINUS [=code points=], and zero or
        more [=ASCII digit=] [=code points=] (in any order). For example,
        "123a-protocol", "abc", or simply "a".
      </dd>
      <dt>
        <dfn data-dfn-for="digital credential" data-local-lt=
        "issuance protocol">Issuance protocol</dfn>
      </dt>
      <dd>
        A standardized protocol used for communication between an [=issuer=]
        and a [=holder=] during the issuance of a [=digital credential=]. The
        issuance protocol is identified by a [=digital credential/protocol
        identifier=]. See [[[#protocols]]].
      </dd>
      <dt>
        Request coordinator
      </dt>
      <dd>
        See [=credential request coordinator=].
      </dd>
    </dl><!--
    // MARK: Protocols
    -->
    <h2 id="protocols">
      Protocols
    </h2>
    <p>
      Use of the following [=digital credential/presentation protocols=] is
      defined by this specification.
    </p>
    <aside class="issue" data-number="439"></aside>
    <table class="data">
      <caption>
        <dfn class="export">Table of supported [=digital
        credential/presentation protocol|presentation=] and [=digital
        credential/issuance protocol|issuance=] protocols</dfn>
      </caption>
      <thead>
        <tr>
          <th scope="col">
            [=digital credential/Protocol identifier|Identifier=]
          </th>
          <th scope="col">
            Specification
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="rowgroup" colspan="2">
            [=digital credential/Presentation protocols=]
          </th>
        </tr>
        <tr>
          <th scope="row">
            <dfn data-dfn-for=
            "DigitalCredentialPresentationProtocol">openid4vp-v1-unsigned</dfn>
          </th>
          <td>
            [[[OPENID4VP]]] ยง <a data-cite=
            "OPENID4VP#name-unsigned-request">A.3.1. Unsigned Request</a>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <dfn data-dfn-for=
            "DigitalCredentialPresentationProtocol">openid4vp-v1-signed</dfn>
          </th>
          <td>
            [[[OPENID4VP]]] ยง <a data-cite=
            "OPENID4VP#name-signed-request">A.3.2. Signed Request</a>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <dfn data-dfn-for=
            "DigitalCredentialPresentationProtocol">openid4vp-v1-multisigned</dfn>
          </th>
          <td>
            [[[OPENID4VP]]] ยง <a data-cite=
            "OPENID4VP#name-jws-json-serialization">A.3.2.2. JWS JSON
            Serialization</a> (Multi-signed requests)
          </td>
        </tr>
        <tr>
          <th scope="row">
            <dfn data-dfn-for=
            "DigitalCredentialPresentationProtocol">org-iso-mdoc</dfn>
          </th>
          <td>
            [[[ISO18013-7]]] ยง Annex C
          </td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <th scope="rowgroup" colspan="2">
            [=digital credential/Issuance protocols=]
          </th>
        </tr>
        <tr>
          <td colspan="2">
            No issuance protocols are currently defined.
          </td>
        </tr>
      </tbody>
    </table><!--
    // MARK: Credential Request Coordinator
    -->
    <h2>
      Credential Request Coordinator
    </h2>
    <p>
      The <dfn data-local-lt="coordinator">credential request coordinator</dfn>
      is a user-agent-defined component that mediates [=digital credential=]
      interactions through the [=top-level traversable=]. Each [=top-level
      traversable=] has exactly one associated coordinator. The coordinator
      ensures that at most one interaction is active across all [=child
      navigables=], orchestrates the end-to-end flow of presentation or
      issuance, and manages transitions between [=credential request
      coordinator/interaction states=].
    </p>
    <p>
      The [=credential request coordinator=] maintains an <dfn data-dfn-for=
      "credential request coordinator">active promise</dfn>, which the user
      agent initializes as `null`. Through this {{Promise}}, the
      [=coordinator=] reflects the state of the asynchronous [=credential
      request=] workflow to script and either [=resolves=] with a [=digital
      credential/credential response=] when the interaction completes
      successfully, or [=rejects=] when processing fails, when the user cancels
      the request via the UI, or when script aborts the operation via an
      {{AbortSignal}}.
    </p>
    <p>
      The [=credential request coordinator=]:
    </p>
    <ul>
      <li>Validates and transforms presentation or issuance inputs and outputs.
      </li>
      <li>Requests the platform to display, for user selection, the credentials
      that are available for the current request and/or the holders that can
      handle the current request. The availability of credentials and holders
      is determined by matching the request parameters, user consent, and
      platform policy.
      </li>
      <li>Manages [=resolve|resolution=] or [=reject|rejection=] of the
      [=credential request coordinator/active promise=] based on the
      interaction outcome.
      </li>
    </ul>
    <p>
      A user agent MAY delegate some or all coordinator responsibilities to
      external wallet applications, platform components, or other trusted
      entities according to user or platform policy.
    </p>
    <aside class="note">
      <p>
        Although the coordinator handles input/output coordination, it is the
        responsibility of the platform together with available [=holders=], to
        present the UI that allows the user to choose a [=digital credential=]
        and/or a [=holder].
      </p>
    </aside>
    <h3>
      Interaction states
    </h3>
    <p>
      The [=credential request coordinator=] has a finite set of
      <dfn data-dfn-for="credential request coordinator">interaction
      states</dfn>, which are used to manage the lifecycle of a [=credential
      request=]:
    </p>
    <dl>
      <dt>
        "<dfn data-dfn-for="credential request coordinator">idle</dfn>":
      </dt>
      <dd>
        No [=credential request=] is currently in progress.
      </dd>
      <dt>
        "<dfn data-dfn-for="credential request coordinator">requesting</dfn>":
      </dt>
      <dd>
        A [=credential request=] is in progress and the user interface is
        presented.
      </dd>
      <dt>
        "<dfn data-dfn-for="credential request coordinator">aborting</dfn>":
      </dt>
      <dd>
        The active interaction is being canceled due to an error, a user
        action, or a [=AbortController/signal abort=]; the coordinator is
        cleaning up before returning to "[=credential request
        coordinator/idle=]".
      </dd>
    </dl>
    <p>
      The coordinator is initialized in the [=credential request
      coordinator/idle=] [=credential request coordinator/interaction state=].
    </p>
    <h3>
      Prepare credential requests
    </h3>
    <p>
      To <dfn data-dfn-for="credential request coordinator">prepare credential
      requests</dfn> given a [=Document=] |document|, a sequence of
      {{DigitalCredentialGetRequest}} or {{DigitalCredentialCreateRequest}}
      objects |requests|, a {{Promise}} |promise|, and an optional
      {{AbortSignal}} |signal|:
    </p>
    <ol class="algorithm">
      <li>Let |global| be |document|'s [=relevant global object=].
      </li>
      <li>If the [=credential request coordinator=] is not in the "[=credential
      request coordinator/idle=]" [=credential request coordinator/interaction
      state=]:
        <ol>
          <li>[=Queue a global task=] on the [=DOM manipulation task source=]
          given |global| to [=reject=] |promise| with an
          {{"InvalidStateError"}} {{DOMException}}.
          </li>
          <li>Return.
          </li>
        </ol>
      </li>
      <li>Assert: the [=credential request coordinator=]'s [=credential request
      coordinator/active promise=] is `null`.
      </li>
      <li>Set the [=credential request coordinator=]'s [=credential request
      coordinator/active promise=] to |promise|.
      </li>
      <li>If |signal| was passed:
        <ol>
          <li>Assert: |signal| is not [=AbortSignal/aborted=].
          </li>
          <li>[=AbortSignal/Add=] the following algorithm to |signal|:
            <ol>
              <li>If the [=credential request coordinator=] is not in the
              "[=credential request coordinator/requesting=]" [=credential
              request coordinator/interaction state=], return.
              </li>
              <li>Set the [=credential request coordinator=] [=credential
              request coordinator/interaction state=] to "[=credential request
              coordinator/aborting=]".
              </li>
              <li>Have the request coordinator dismiss the [=credential
              chooser=] and await confirmation of dismissal before it returns
              to the [=credential request coordinator/idle=] [=credential
              request coordinator/interaction state=].
              </li>
              <li>Let |error| be |signal|'s [=AbortSignal/abort reason=].
              </li>
              <li>[=credential request coordinator/Complete credential request
              with=] |error|.
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Let |validatedRequests| be a new empty [=list=].
      </li>
      <li>[=List/For each=] |request| of |requests|:
        <ol>
          <li>Let |protocol| be |request|'s
          {{DigitalCredentialGetRequest/protocol}}, if |request| is a
          {{DigitalCredentialGetRequest}}, or |request|'s
          {{DigitalCredentialCreateRequest/protocol}}, if |request| is a
          {{DigitalCredentialCreateRequest}}.
          </li>
          <li>If |protocol| does not equal any [=enumeration value=] in
          {{DigitalCredentialProtocol}}, [=iteration/continue=].
          </li>
          <li>If the [=user agent=] does not support |protocol|,
          [=iteration/continue=].
          </li>
          <li>Let |validatedRequest| be the result of validating |request|'s
          [=digital credential/request data=] according to |request|'s
          [=digital credential/exchange protocol=]. Validation requirements are
          protocol-specific and are outside the scope of this specification.
            <aside class="note" title="Validation details outside scope">
              <p>
                Validation includes verifying |request|'s [=digital
                credential/request data=] conforms to the requirements of the
                specified [=digital credential/exchange protocol=]. Please
                refer to the specification of the specific [=digital
                credential/exchange protocol=] for details, including potential
                reasons for validation failure, and any security and privacy
                considerations that need to be considered by implementers
                during validation.
              </p>
            </aside>
          </li>
          <li>If |validatedRequest| is an [=exception=]:
            <ol>
              <li>[=credential request coordinator/Complete credential request
              with=] |validatedRequest|.
              </li>
              <li>Return.
              </li>
            </ol>
          </li>
          <li>[=list/Append=] |validatedRequest| to |validatedRequests|.
          </li>
        </ol>
      </li>
      <li>If |validatedRequests| [=list/is empty=]:
        <ol>
          <li>[=credential request coordinator/Complete credential request
          with=] a newly created {{TypeError}}.
          </li>
          <li>Return.
          </li>
        </ol>
      </li>
      <li>Set the [=credential request coordinator=] [=credential request
      coordinator/interaction state=] to "[=credential request
      coordinator/requesting=]".
      </li>
      <li>[=credential request coordinator/Present the credential request=]
      with |document|, |validatedRequests|, and |signal|.
      </li>
    </ol>
    <h3>
      Abort the credential request
    </h3>
    <p>
      To be written.
    </p>
    <h3>
      Complete credential request with error
    </h3>
    <p>
      To <dfn data-dfn-for="credential request coordinator" data-local-lt=
      "complete credential request with">complete credential request with
      error</dfn> (a JavaScript Value) |error|:
    </p>
    <ol class="algorithm">
      <li>Assert: the [=credential request coordinator=]'s [=credential request
      coordinator/active promise=] is not `null`.
      </li>
      <li>[=Queue a global task=] on the [=DOM manipulation task source=] given
      |error|'s [=relevant global object=] to perform the following steps:
        <ol>
          <li>If the [=credential request coordinator=]'s [=credential request
          coordinator/active promise=] is `null`, then return.
          </li>
          <li>[=Reject=] the [=credential request coordinator=]'s [=credential
          request coordinator/active promise=] with |error|.
          </li>
          <li>Set the [=credential request coordinator=]'s [=credential request
          coordinator/active promise=] to `null`.
          </li>
          <li>Set the [=credential request coordinator=] [=credential request
          coordinator/interaction state=] to "[=credential request
          coordinator/idle=]".
          </li>
        </ol>
      </li>
    </ol>
    <h3>
      Present the credential request
    </h3>
    <p>
      <dfn data-dfn-for="credential request coordinator">Present the credential
      request</dfn> to be written.
    </p><!--
    // MARK: The Digital Credentials API
    -->
    <h2>
      The Digital Credentials API
    </h2>
    <p>
      The Digital Credentials API leverages the [[[credential-management]]]
      specification, allowing [=user agents=] to mediate the [=digital
      credential/issuance=] and [=digital credential/presentation=] of
      [=digital credentials=].
    </p>
    <p>
      The API allows [=digital credential/presentation request|requesting=] a
      [=digital credential=] from the user agent, which in turn presents a
      [=credential chooser=] to the user, allowing them to select a [=digital
      credential=] that can fulfill the request. This is done by the website
      calling the `navigator.credentials.`{{CredentialsContainer/get()}}
      method, which runs the [=request a `Credential`=] algorithm of
      [[[credential-management]]]. That algorithm then calls back into this
      specification's {{DigitalCredential}} interface's
      {{DigitalCredential/[[DiscoverFromExternalSource]](origin, options,
      sameOriginWithAncestors)}} internal method.
    </p>
    <p>
      Additionally, the API also allows [=digital credential/Issuance
      request|requesting issuance=] of a [=digital credential=], which
      initiates an mediated issuance flow between the user agent and/or a
      [=holder=]. This is done by calling the
      `navigator.credentials.`{{CredentialsContainer/create()}} method, which
      runs the [=create a credential=] algorithm of
      [[[credential-management]]]. That algorithm then calls back into this
      specification's {{DigitalCredential}} interface's
      {{Credential/[[Create]](origin,options, sameOriginWithAncestors)}}
      internal method.
    </p>
    <p>
      Please see [[[#credential-management-integration]]] for complete details
      of how to integrate with the [[[credential-management]]] specification.
    </p><!--
    // MARK: CredentialRequestOptions
    -->
    <h3>
      Extensions to `CredentialRequestOptions` dictionary
    </h3>
    <pre class="idl">
    partial dictionary CredentialRequestOptions {
      DigitalCredentialRequestOptions digital;
    };
    </pre>
    <h4>
      The `digital` member
    </h4>
    <p>
      The <dfn data-dfn-for="CredentialRequestOptions">digital</dfn> member
      allows for options to configure the request for a [=digital credential=].
    </p><!--
    // MARK: DigitalCredentialRequestOptions
    -->
    <h3>
      The `DigitalCredentialRequestOptions` dictionary
    </h3>
    <pre class="idl">
    dictionary DigitalCredentialRequestOptions {
      required sequence&lt;DigitalCredentialGetRequest&gt; requests;
    };
    </pre>
    <h4>
      The `requests` member
    </h4>
    <p>
      The <dfn data-dfn-for="DigitalCredentialRequestOptions">requests</dfn>
      specify an [=digital credential/presentation protocol=] and [=digital
      credential/request data=], which the user agent MAY match against a
      holder's software, such as a digital wallet.
    </p><!--
    // MARK: DigitalCredentialGetRequest
    -->
    <h3>
      The `DigitalCredentialGetRequest` dictionary
    </h3>
    <p>
      The {{DigitalCredentialGetRequest}} dictionary represents a [=digital
      credential/presentation request=]. It is used to specify an [=digital
      credential/presentation protocol=] and some [=digital credential/request
      data=], which the user agent MAY match against software used by a holder,
      such as a digital wallet.
    </p>
    <pre class="idl">
      dictionary DigitalCredentialGetRequest {
        required DOMString protocol;
        required object data;
      };
    </pre>
    <h4>
      The `protocol` member
    </h4>
    <p>
      The <dfn data-dfn-for="DigitalCredentialGetRequest">protocol</dfn> member
      denotes the [=digital credential/presentation protocol=].
    </p>
    <p>
      The {{DigitalCredentialGetRequest/protocol}} member's value is one of the
      protocol identifiers defined in
      {{DigitalCredentialPresentationProtocol}}.
    </p>
    <h4>
      The `data` member
    </h4>
    <p>
      The <dfn data-dfn-for="DigitalCredentialGetRequest">data</dfn> member is
      the [=digital credential/request data=] to be handled by the holder's
      credential provider, such as a digital identity wallet.
    </p><!--
    // MARK: CredentialCreationOptions
    -->
    <h3>
      Extensions to `CredentialCreationOptions` dictionary
    </h3>
    <pre class="idl">
    partial dictionary CredentialCreationOptions {
      DigitalCredentialCreationOptions digital;
    };
    </pre>
    <h4>
      The `digital` member
    </h4>
    <p>
      The <dfn data-dfn-for="CredentialCreationOptions">digital</dfn> member
      allows for options to configure the issuance of a [=digital credential=].
    </p><!--
    // MARK: DigitalCredentialCreationOptions
    -->
    <h3>
      The `DigitalCredentialCreationOptions` dictionary
    </h3>
    <pre class="idl">
    dictionary DigitalCredentialCreationOptions {
      required sequence&lt;DigitalCredentialCreateRequest&gt; requests;
    };
    </pre>
    <h4>
      The `requests` member
    </h4>
    <p>
      The <dfn data-dfn-for="DigitalCredentialCreationOptions">requests</dfn>
      specify an [=digital credential/issuance protocol=] and [=digital
      credential/request data=], which the user agent MAY forward to a
      [=holder=].
    </p><!--
    // MARK: DigitalCredentialCreateRequest
    -->
    <h3>
      The `DigitalCredentialCreateRequest` dictionary
    </h3>
    <p>
      The {{DigitalCredentialCreateRequest}} dictionary represents an [=digital
      credential/issuance request=]. It is used to specify an [=digital
      credential/issuance protocol=] and some [=digital credential/request
      data=], to communicate the issuance request between the issuer and the
      holder.
    </p>
    <pre class="idl">
    dictionary DigitalCredentialCreateRequest {
      required DOMString protocol;
      required object data;
    };
    </pre>
    <h4>
      The `protocol` member
    </h4>
    <p>
      The <dfn data-dfn-for="DigitalCredentialCreateRequest">protocol</dfn>
      member denotes the [=digital credential/issuance protocol=].
    </p>
    <p>
      The {{DigitalCredentialCreateRequest/protocol}} member's value is one of
      the protocol identifiers defined in [[[#protocols]]].
    </p>
    <h4>
      The `data` member
    </h4>
    <p>
      The <dfn data-dfn-for="DigitalCredentialCreateRequest">data</dfn> member
      is the [=digital credential/request data=] to be handled by the holder's
      credential provider, such as a digital identity wallet.
    </p><!--
    // MARK: DigitalCredential interface
    -->
    <h3>
      The `DigitalCredential` interface
    </h3>
    <p>
      The <dfn>DigitalCredential</dfn> interface represents a conceptual
      [=digital credential=].
    </p>
    <p>
      The {{DigitalCredential}} interface mandates [=user mediation=] for all
      operations to ensure user control and consent.
    </p>
    <p>
      To simplify the developer experience of {{CredentialsContainer/get()}}
      calls involving a {{DigitalCredential}}, [=user agents=] MUST NOT throw
      an error if the {{CredentialRequestOptions/mediation}} member is absent
      or has a value other than {{CredentialMediationRequirement/"required"}}.
      Similarly, in {{CredentialsContainer/create()}} calls involving a
      {{DigitalCredential}}, [=user agents=] MUST NOT throw an error if the
      {{CredentialCreationOptions/mediation}} member is absent or has a value
      other than {{CredentialMediationRequirement/"required"}}. This makes
      {{CredentialMediationRequirement/"required"}} mediation an implicit and
      non-overridable behavior of the API.
    </p>
    <pre class="idl">
    typedef DigitalCredentialPresentationProtocol DigitalCredentialProtocol;

    [Exposed=Window, SecureContext]
    interface DigitalCredential : Credential {
      [Default] object toJSON();
      readonly attribute DigitalCredentialProtocol protocol;
      [SameObject] readonly attribute object data;
      static boolean userAgentAllowsProtocol(DOMString protocol);
    };
    </pre>
    <p>
      {{DigitalCredential}} instances are [=Credential/origin bound=].
    </p>
    <h4>
      The `protocol` member
    </h4>
    <p>
      The <dfn data-dfn-for="DigitalCredential">protocol</dfn> member is the
      [=digital credential/presentation protocol=] that was used to request the
      [=digital credential=], or the [=digital credential/issuance protocol=]
      that was used to issue the [=digital credential=].
    </p>
    <h4>
      The `data` member
    </h4>
    <p>
      The <dfn data-dfn-for="DigitalCredential">data</dfn> member is the
      credential's response data. It contains the subset of JSON-parseable
      object types.
    </p>
    <h4>
      The <dfn data-dfn-for="DigitalCredential">userAgentAllowsProtocol()</dfn>
      method
    </h4>
    <p>
      The {{DigitalCredential/userAgentAllowsProtocol()}} method allows digital
      credential [=verifiers=] to determine which [=digital
      credential/presentation protocols=] and [=digital credential/issuance
      protocols=] the user agent allows.
    </p>
    <p class="note">
      This method does not convey [=digital credential/presentation protocol=]
      or [=digital credential/issuance protocol=] support in the underlying
      OS/platform.
    </p>
    <p>
      User agents MUST NOT vary the response value based on any information
      about availability of hardware, presence or configuration of software,
      wallets, credential providers, or digital credentials, or user
      configuration or preferences. If the response value varied, the user
      agent would introduce risks both of fingerprinting and of silently
      revealing other details about user behavior or configuration. The
      response value SHOULD vary only by user agent major version and indicate
      whether the browser supports distributing requests with that protocol to
      underlying platform or provider.
    </p>
    <p>
      When this method is invoked, the user agent MUST execute the following
      algorithm:
    </p>
    <ol class="algorithm">
      <li>If |protocol| is not an [=enumeration value=] of
      {{DigitalCredentialProtocol}}, return `false`.
      </li>
      <li>Return `true` if the user agent allows |protocol|, otherwise return
      `false`.
      </li>
    </ol>
    <h3>
      Supporting Data Structures
    </h3>
    <p>
      Data structures, such as enumerations, which support
      {{DigitalCredential}} in this specification.
    </p>
    <h4>
      The {{DigitalCredentialPresentationProtocol}} enumeration
    </h4>
    <p>
      This enumeration's values correspond to the supported [=digital
      credential/presentation protocols=] listed in [[[#protocols]]].
    </p>
    <pre class="idl">
      enum DigitalCredentialPresentationProtocol {
        "openid4vp-v1-unsigned",
        "openid4vp-v1-signed",
        "openid4vp-v1-multisigned",
        "org-iso-mdoc"
      };
      </pre>
    <h2 id="credential-management-integration">
      Integration with [[[credential-management]]]
    </h2><!--
    // MARK: [[\DiscoverFromExternalSource]]
    -->
    <h3>
      [[\DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)
      internal method
    </h3>
    <p>
      When invoked, the <dfn class="export" data-dfn-for=
      "DigitalCredential">[[\DiscoverFromExternalSource]](origin, options,
      sameOriginWithAncestors)</dfn> internal method, if the user agent doesn't
      support [=digital credential/presentation requests=] (e.g., the platform
      cannot provide a [=credential chooser=]), call the default implementation
      of {{Credential}}'s {{Credential/[[DiscoverFromExternalSource]](origin,
      options, sameOriginWithAncestors)}} internal method with the same
      arguments. Otherwise:
    </p>
    <ol class="algorithm">
      <li>Let |global| be [=this=]'s [=relevant global object=].
      </li>
      <li>Let |document| be |global|'s [=associated `Document`=].
      </li>
      <li>If |document| is not a [=Document/fully active descendant of a
      top-level traversable with user attention=], return [=a promise rejected
      with=] a {{"NotAllowedError"}} {{DOMException}}.
      </li>
      <li>Let |requests| be |options|'s {{CredentialRequestOptions/digital}}'s
      {{DigitalCredentialRequestOptions/requests}} member.
      </li>
      <li>If |requests| [=list/is empty=], return [=a promise rejected with=] a
      {{TypeError}}.
      </li>
      <li>[=List/For each=] |request| of |requests|:
        <ol>
          <li>[=serialize a JavaScript value to a JSON string|Serialize=]
          |request|'s {{DigitalCredentialGetRequest/data}} to a JSON string.
          </li>
          <li>If serialization results in an [=exception=], return [=a promise
          rejected with=] that [=exception=].
          </li>
        </ol>
      </li>
      <li>If |global| does not have [=transient activation=], return [=a
      promise rejected with=] a {{"NotAllowedError"}} {{DOMException}}.
      </li>
      <li>[=Consume user activation=] of |global|.
      </li>
      <li>
        <aside class="issue">
          Details of how to actually get the [=digital credential=] are
          forthcoming.
        </aside>
      </li>
      <li>Let |promise| be [=a new promise=].
      </li>
      <li>Let |signal| be |options|'s {{CredentialRequestOptions/signal}} if
      present.
      </li>
      <li>[=credential request coordinator/Prepare credential requests=] with
      |document|, |requests|, |promise|, and |signal|.
      </li>
      <li>Return |promise|.
      </li>
    </ol><!--
    // MARK: [[Store]]()
    -->
    <h3>
      [[\Store]](credential, sameOriginWithAncestors) internal method
    </h3>
    <p>
      When invoked, the <dfn class="export" data-dfn-for=
      "DigitalCredential">[[\Store]](credential, sameOriginWithAncestors)</dfn>
      MUST call the default implementation of {{Credential}}'s
      {{Credential/[[Store]](credential, sameOriginWithAncestors)}} internal
      method with the same arguments.
    </p><!--
    // MARK: [[Create]]()
    -->
    <h3>
      [[\Create]](origin, options, sameOriginWithAncestors) internal method
    </h3>
    <p>
      When invoked, the <dfn class="export" data-dfn-for=
      "DigitalCredential">[[\Create]](origin, options,
      sameOriginWithAncestors)</dfn> internal method, if the user agent doesn't
      support [=digital credential/issuance requests=], call the default
      implementation of {{Credential}}'s {{Credential/[[Create]](origin,
      options, sameOriginWithAncestors)}} internal method with the same
      arguments. Otherwise:
    </p>
    <ol class="algorithm">
      <li>Let |global| be [=this=]'s [=relevant global object=].
      </li>
      <li>Let |document| be |global|'s [=associated `Document`=].
      </li>
      <li>If |document| is not a [=Document/fully active descendant of a
      top-level traversable with user attention=], return [=a promise rejected
      with=] a {{"NotAllowedError"}} {{DOMException}}.
      </li>
      <li>Let |requests| be |options|'s {{CredentialCreationOptions/digital}}'s
      {{DigitalCredentialCreationOptions/requests}} member.
      </li>
      <li>If |requests| is [=list/is empty=], return [=a promise rejected
      with=] a {{TypeError}}.
      </li>
      <li>[=List/For each=] |request| of |requests|:
        <ol>
          <li>[=serialize a JavaScript value to a JSON string|Serialize=]
          |request|'s {{DigitalCredentialGetRequest/data}} to a JSON string.
          </li>
          <li>If serialization results in an [=exception=], return [=a promise
          rejected with=] that [=exception=].
          </li>
        </ol>
      </li>
      <li>If |global| does not have [=transient activation=], return [=a
      promise rejected with=] a {{"NotAllowedError"}} {{DOMException}}.
      </li>
      <li>[=Consume user activation=] of |global|.
      </li>
      <li>
        <aside class="issue">
          Details of how to actually issue the [=digital credential=] are
          forthcoming.
        </aside>
      </li>
      <li>Let |promise| be [=a new promise=].
      </li>
      <li>Let |signal| be |options|'s {{CredentialRequestOptions/signal}} if
      present.
      </li>
      <li>[=credential request coordinator/Prepare credential requests=] with
      |document|, |requests|, |promise|, and |signal|.
      </li>
      <li>Return |promise|.
      </li>
    </ol><!--
    // MARK: [[type]] internal slot
    -->
    <h3>
      [[\type]] internal slot
    </h3>
    <p>
      The {{DigitalCredential}} [=interface object=] has an internal slot named
      <dfn class="export" data-dfn-for="DigitalCredential">[[\type]]</dfn>
      whose value is "digital".
    </p><!--
    // MARK: [[discovery]] internal slot
    -->
    <h3>
      [[\discovery]] internal slot
    </h3>
    <p>
      The {{DigitalCredential}} [=interface object=] has an internal slot named
      <dfn class="export" data-dfn-for="DigitalCredential">[[\discovery]]</dfn>
      whose value is "remote".
    </p><!--
      // MARK: User permission
      -->
    <h3 class="informative">
      User permission
    </h3>
    <p data-cite="permissions">
      The <cite>Digital Credential API</cite> is a [=powerful feature=] that
      requires [=express permission=] from an end-user. This requirement is
      normatively enforced when calling {{CredentialsContainer}}'s
      {{CredentialsContainer/get()}} method.
    </p>
    <section id="permissions-policy" data-cite="permissions-policy">
      <!--
      // MARK: Permissions Policy
      -->
      <h2>
        Permissions Policy integration
      </h2>
      <p>
        This specification defines two [=policy-controlled features=]:
      </p>
      <dl>
        <dt>
          <dfn class="permission">"digital-credentials-get"</dfn>
        </dt>
        <dd>
          A [=policy-controlled feature=] that allows a [=document=] to
          [=digital credential/presentation request|request=] digital
          credentials. Its [=policy-controlled feature/default allowlists=] is
          [=default allowlist/'self'=]. The [=request a `Credential`=]
          algorithm serves as the policy enforcement point.
        </dd>
        <dt>
          <dfn class="permission">"digital-credentials-create"</dfn>
        </dt>
        <dd>
          A [=policy-controlled feature=] that allows a [=document=] to
          [=digital credential/issuance request|issue=] digital credentials.
          Its [=policy-controlled feature/default allowlists=] is [=default
          allowlist/'self'=]. The [=create a `Credential`=] algorithm serves as
          the policy enforcement point.
        </dd>
      </dl>
    </section>
    <section class="informative">
      <!--
      // MARK: Security Considerations
      -->
      <h2>
        Security Considerations
      </h2>
      <p>
        To be written.
      </p>
    </section>
    <section class="informative" data-cite="privacy-principles">
      <!--
      // MARK: Privacy Considerations
      -->
      <h2>
        Privacy Considerations
      </h2>
      <div class="issue" title=
      "Privacy Considerations section is a work in progress">
        <p>
          This section is a work in progress as this document evolves.
        </p>
      </div>
      <p>
        The Digital Credentials API integrates into a complex ecosystem with
        multiple technology layers and various participants (including but not
        limited to [=verifiers=], [=holders=], and [=issuers=]), each of which
        have to consider different aspects of user privacy. This specification
        does not attempt to exhaustively list all considerations for the
        different participants. We would like to refer these parties to a
        variety of other resources that explore the digital credentials threat
        model more holistically:
      </p>
      <ul>
        <li>[[[credential-considerations]]]
        </li>
        <li>[[[threat-model-decentralized-identities]]]
        </li>
        <li>
          <a data-cite="vc-data-model#privacy-considerations">VC Data Model
          Privacy Considerations</a>
        </li>
        <li>...
        </li>
      </ul>
      <p>
        Instead, these considerations focus on the Digital Credentials API
        itself, and describe how [=user agents=] can satisfy their [=user agent
        duties=] in an implementation of the API, taking into account the
        relevant privacy properties of the ecosystem it interacts with.
      </p>
      <p>
        The privacy considerations for digital credentials are not static. They
        will evolve over time as the ecosystem matures, and may be informed by
        the behavior of other actors in the ecosystem, improvements in other
        layers of the stack, new threats to user privacy, as well as changing
        societal norms and regulations.
      </p>
      <p>
        It is expected that the various groups involved in the design and
        implementation of the Digital Credentials API actively monitor the
        evolving privacy landscape and participate in the corresponding
        evolution of the API.
      </p>
      <section>
        <!--
        // MARK: Design Considerations and Alternatives
        -->
        <h3>
          Design Considerations and Alternatives
        </h3>
        <p>
          The Digital Credentials API is designed to mediate requests for
          digital credentials from websites, being agnostic to the credential
          format and the information contained in it, as well as the protocol
          used to exchange it. This and other key design choices are derived
          from the goal of providing a more secure and private credential
          exchange experience for users than the existing alternatives (e.g.,
          [[custom-schemes]]), that is still compatible with common exchange
          protocols for ease of adoption.
        </p>
        <p>
          The API provides the connection interface between [=verifiers=] and
          [=holders=], i.e. the means by which a [=digital
          credential/presentation protocol|credential presentation protocol=]
          is initiated and the user switches to the [=holder=] application to
          select a credential. Solutions that have been used for this purpose
          in the past include QR codes and custom URL schemes. As documented in
          [[[presenting-credentials-on-the-web]]] and [[[custom-schemes]]],
          those solutions have security, privacy, and accessibility concerns.
        </p>
        <p>
          With adoption of digital credential technology being driven by
          ecosystem demand and regulatory mandates, the Web platform offers an
          alternative to the aforementioned less-desirable technologies that is
          easy to use for developers, is compatible with existing credential
          [=digital credential/presentation protocols=] and, most importantly,
          has better user privacy, security, and accessibility properties than
          these alternatives.
        </p>
        <p>
          The Digital Credentials API offers the [=user agent=] the ability to
          intermediate on behalf of the user (e.g. in the form of a
          [=credential chooser=]) to contextualize requests and <a href=
          "#permission-prior-to-wallet-selection">prevent immediate exposure to
          holder applications</a>. It also enforces certain minimum
          requirements on supported protocols, such as <a href=
          "#encrypting-credential-responses">response encryption</a>.
        </p>
        <aside class="note">
          The Digital Credentials API is not intended to inhibit the
          development of other standardized solutions that enhance user
          privacy. For example, an API could be standardized that more strictly
          enforces unlinkability for specific purposes such as age
          verification. Higher-level, designed-for-purpose APIs often enable
          <a data-cite="privacy-principles#purpose-limitation">purpose
          limitation</a>, ease of explanation to the user, and privacy and
          security protections from <a data-cite=
          "design-principles#high-level-low-level">user agents</a>.
        </aside>
      </section>
      <section data-cite="vc-data-model#spectrum-of-privacy">
        <!--
        // MARK: Spectrum of Privacy
        -->
        <h3>
          Spectrum of Privacy
        </h3>
        <p>
          The Digital Credentials API serves a variety of use cases with
          different grades of data disclosure and individual users with
          different preferences depending on the context that they are in.
          Notably, the privacy properties of a credential exchange mediated by
          this API could be mandated by the legal and regulatory environment of
          an individual user.
        </p>
        <p>
          This means that some users may not want, or be allowed, to use the
          most privacy-preserving means of exchanging credential information.
          Nonetheless, [=user agents=] need to serve users with an experience
          that is private by default and protect them from harm.
        </p>
        <p>
          Because of this spectrum of preferences and use cases, it may be
          difficult for a [=user agent=] to discern whether a user means to
          expose their personal information or is being tricked into doing so.
          It is thus the [=user agent=]'s responsibility to ensure that every
          user understands what data they are sharing and who will participate
          in the exchange of information, before the exchange begins.
        </p>
      </section>
      <section>
        <!--
        // MARK: Presentation Protocol and Credential Format
        -->
        <h3>
          Presentation Protocol and Credential Format
        </h3>
        <p>
          Because the Digital Credentials API sits at the center of an exchange
          that involves multiple independent parties, the [=digital
          credential/presentation protocol=] and credential format used by
          these parties for exchanging user information are crucial to the
          [=user agent=]'s goal of protecting user privacy.
        </p>
        <h4>
          Presentation Protocol Considerations for User Privacy
        </h4>
        <aside class="issue" data-number="255"></aside>
        <h5>
          Selective disclosure
        </h5>
        <p>
          <a data-cite=
          "credential-considerations#selective-disclosure">Selective
          disclosure</a> is a fundamental technique for <a data-cite=
          "privacy-principles#data-minimization">data minimization</a> that
          allows [=holders=] to share the minimum required information that is
          requested by a [=verifier=]. Protocols are expected to facilitate
          selective disclosure by allowing the [=verifier=] to specify the
          exact claims needed.
        </p>
        <h5>
          Unlinkable presentations
        </h5>
        <p>
          <a data-cite=
          "credential-considerations#unlinkable-presentations">Unlinkability</a>
          is a property that ensures that, if a user presents attributes from a
          credential multiple times, [=verifiers=] cannot link these separate
          presentations to conclude they concern the same user
          (verifier-verifier linkability), or that [=verifiers=] cannot collude
          with [=issuers=] to report the exchange of a credential from a
          digital wallet to the [=issuer=] (verifier-issuer linkability). The
          former is a property that can be maintained by the [=holder=] and
          [=issuer=], e.g. through issuing fresh credentials for individual
          [=verifiers=].
        </p>
        <p>
          While the latter is achievable, e.g. through <a data-cite=
          "vc-data-model#zero-knowledge-proofs">Zero-Knowledge Proofs</a>,
          design choices of the API such as encrypted responses make it
          impossible for a [=user agent=] to prove that verifier-issuer
          unlinkability was achieved in practice. Nonetheless, protocols are
          requested to limit linkability wherever possible.
        </p>
        <p>
          Note that unlinkability is exclusively a consideration for attributes
          that cannot be linked to a specific user identity. Inherently
          linkable attributes such as names, driver's license numbers or phone
          numbers do not benefit from unlinkability.
        </p>
        <p>
          Through the Digital Credentials API, the [=user agent=] can help
          [=verifiers=] and digital wallets exchange unlinkable attributes,
          but, because of response encryption, it cannot guarantee that no
          linkable information is passed between [=verifiers=] and digital
          wallets. It is recommended that [=user agents=] account for this fact
          in their user permission experience.
        </p>
        <p class="issue" data-number="279">
          Which level of unlinkability is the goal for this API? Can we
          normatively enforce support for any particular unlinkability
          features?
        </p>
        <h5>
          "Phone home" mechanisms
        </h5>
        <p>
          <a data-cite="credential-considerations#no-phoning-home">"Phoning
          home"</a> refers to scenarios where the presentation or verification
          of a digital credential causes a notification or communication back
          to the [=issuer=] or another central entity, which can lead to
          tracking and profiling of individuals.
        </p>
        <p>
          Similar to unlinkability, it is impossible for [=user agents=] to
          ensure that an [=issuer=] isn't actively involved in the creation or
          validation of credential presentations after a user has given
          permission to proceed with a credential request. From that point on,
          the digital wallet application owns this decision. While some digital
          wallets can be considered [=user agents=], it is generally
          recommended that the [=user agent=] implementing the Digital
          Credentials API designs its permission experience to prevent <a href=
          "#permission-prior-to-wallet-selection">exposure of a request to the
          digital wallet application</a> before user confirmation (keeping in
          mind <a href="#multiple-user-agents">considerations for integrating
          multiple cooperating user agents</a>).
        </p>
        <p>
          Protocols are required to support mechanisms that allow [=issuers=],
          digital wallets, and [=verifiers=] to avoid or reduce the dependence
          on "phone home" mechanisms.
        </p>
        <p class="issue" data-number="279">
          Which level of unlinkability is the goal for this API? To what degree
          can the spec mandate restrictions to [=issuer=] involvement?
        </p>
        <h5>
          Unlinkable revocation
        </h5>
        <p>
          A common instance of [=issuer=] involvement in a credential exchange
          is for credential revocation checks. This is particularly challenging
          when presentations are intended to be verifier-issuer unlinkable.
          When credential presentations are made unlinkable through the use of
          e.g. Zero-Knowledge Proofs, the credential formats used in protocols
          are expected to support offline revocation methods such as <a href=
          "https://eprint.iacr.org/2024/657.pdf">Cryptographic
          Accumulators</a>. It is further expected that protocol design and
          specification discourages the involvement of [=verifiers=] for the
          purpose of revocation where possible.
        </p>
        <p class="issue" data-number="280">
          We should discuss whether unlinkable revocation techniques are
          practical enough to be required normatively.
        </p>
        <h5>
          Support for user transparency, permission and consent
        </h5>
        <p>
          User understanding and participation are non-negotiable properties of
          a credential presentation. The protocol is expected to help all
          involved parties enable user participation by providing the
          information vital for informed permission and/or consent.
        </p>
        <h5>
          Support for verifier authorization
        </h5>
        <p>
          Verifier authorization refers to the process by which a [=verifier=]
          proves its identity and demonstrates that it is legitimately entitled
          to request specific attributes or credentials. This is particularly
          useful when exchanging sensitive data, such as from government-issued
          credentials. Verifier authorization can limit unnecessary or abusive
          credential requests, and ensure that a [=verifier=]'s access is
          restricted to the specific credential attributes it registered for.
        </p>
        <p>
          Checking verifier authorization is usually handled by the digital
          wallet, but [=user agents=] could find the presence of such a scheme
          helpful in preventing API abuse and designing a well-informed user
          permission experience.
        </p>
        <p class="issue" data-number="281">
          Should we require protocols to include provisions that allow [=user
          agents=] to understand verifier authorization?
        </p>
        <h5>
          Encrypting credential responses
        </h5>
        <p>
          To prevent exposure of user information to other parties in
          "transit", for example browser extensions loaded on [=verifier=]
          pages, and to encourage secure storage of user credentials by the
          [=verifier=], protocols are required to support and mandate encrypted
          responses in a credential exchange.
        </p>
        <p class="issue" data-number="109"></p>
      </section>
      <section>
        <!--
        // MARK: Unnecessary Requests for Credentials
        -->
        <h3>
          Unnecessary Requests for Credentials
        </h3>
        <p>
          Unnecessary credential requests are a key privacy risk to the entire
          digital credentials ecosystem. They could manifest in different ways
          and from different motivations:
        </p>
        <ul>
          <li>Intentional abuse of the API to learn sensitive information about
          the user for the purpose of fraud, tracking, or sale of the data. For
          example, a site could trick a user into sharing their passport
          information through misleading content. This can lead to identity
          theft and financial loss, and severe loss of control and/or leakage
          of personal information.
          </li>
          <li>Unnecessary requests for credentials without the explicit intent
          of user harm, such as an online store requesting users to sign up
          with their driver's license instead of generic email & passkey or
          federated credentials. This can lead to <a data-cite=
          "identity-web-impact#opportunities-and-threats">exclusion</a> of
          users without the ability or willingness to share such a credential
          with the site, a deterioration of the prompt experience on the web,
          and an increase in the risk of accidental data leakage.
          </li>
          <li>Requests for an excessive amount of information for valid
          purposes against the principle of data minimization. A common example
          is collection of a user's entire national identity document for age
          verification instead of relying on selective disclosure and age
          predicates.
          </li>
        </ul>
        <p>
          One challenge here is determining what constitutes "valid" purposes
          and which requests are therefore "unnecessary", and requires
          participation from all parties involved in the credential exchange.
        </p>
        <ul>
          <li>Ideally, [=verifiers=] would self-regulate their requests for
          credentials. However, from a [=user agent=]'s perspective,
          [=verifiers=] are potential attackers, and might not consider the
          user's best interest in their designs. The Digital Credentials API
          needs to operate from an assumption that all [=verifiers=] might have
          incentives that motivate unnecessary requests and abuse, and protect
          users accordingly.
          </li>
          <li>[=user agents=] are responsible for protecting their users
          against dangerous content and permission requests on the Web and
          could intervene on their behalf, proactively rejecting requests or
          requiring pre-authorization. To support this, the Digital Credentials
          API requires credential requests to be readable by the [=user agent=]
          (i.e., not end-to-end encrypted to the [=verifier=]).
          </li>
          <li>[=issuers=] and lawmakers might decide to restrict use of
          (particularly government-issued) credentials to specific
          [=verifiers=] with purpose attestations. Digital wallets might be
          expected to enforce these restrictions by law or policy.
          </li>
          <li>The ultimate decision of whether or not to share their personal
          information lies with the user, which is why the API requires the
          [=user agent=] to present a credential picker to the user, and other
          parties might additionally require confirmation or consent.
          </li>
        </ul>
        <p>
          For a more detailed exploration of how to determine and address
          unnecessary usage, it makes sense to consider government-issued
          credentials and other credentials separately, as they potentially
          differ in the sensitivity of their data and the potential harms from
          misuse as well as legal & regulatory considerations.
        </p>
        <p>
          A key component of risk mitigation and ensuring user control that
          applies to both types of credentials is the [=user agent=]'s ability
          to inspect the credential request metadata and make decisions or UI
          presentation based on it. The DC API ensures this [=user agent=]
          access to the presentation through requirements placed on protocols
          to transmit requests unencrypted and to include relevant information.
        </p>
        <h4>
          Government-issued credentials
        </h4>
        <p>
          <a data-cite=
          "identity-web-impact#pure-digital-credentials">Government-issued
          digital credentials</a> include travel documents, personal licenses,
          proof of welfare and public health programs, vehicle registrations,
          and other documents issued by government authorities, or other
          documents representing this information. These documents are highly
          sensitive, as they can contain permanent, irrevocable, unique
          identifiers that are central to a person's individual identity and
          ability to interact with vital public services.
        </p>
        <h5>
          Risk of theft and leakage of government credentials
        </h5>
        <p>
          The high value of these credentials to users and attackers means
          there is a significant risk of theft, and significant potential harm
          from leakage to unauthorized third parties. This includes the request
          of government identity for the purpose of tracking and
          personalization.
        </p>
        <h5>
          Risk of proliferation of requests for government credentials
        </h5>
        <p>
          A major concern with increased availability of government credentials
          online is <a href=
          "https://en.wikipedia.org/wiki/Jevons_paradox">Jevon's Paradox</a>,
          i.e., the chance of increasing demand for credentials through lower
          friction of access. This effect is not inherently caused by the
          Digital Credentials API, but rather the overall increasing adoption
          of digital credentials across the ecosystem, which, however, would
          likely see additional momentum from [=user agent=] implementation of
          the Digital Credentials API. As such, the effect needs to be
          considered by [=user agents=] implementing the API, as it might
          result in harmful outcomes for users:
        </p>
        <ul>
          <li>Increased risk of information leakage, and ultimately a less
          trusted user experience on the Web. When a large number of services
          access and store government-issued credentials in an insecure manner
          (i.e. not maintaining encryption or failing to safeguard private
          keys), the chance of data leaks and unauthorized access increases as
          well. Even seemingly non-identifying information like birthdates and
          postal codes, when combined, can statistically identify an
          individual.
          </li>
          <li>Prompt fatigue and a loss in trust by users when they are
          prompted by a large number of websites to share personal information.
          </li>
          <li>Increased potential for <a data-cite=
          "rfc6973#section-5.1.1">surveillance</a> and restrictions on
          pseudonymous use of online services. Collusion between [=verifiers=]
          and [=issuers=], or other parties, might result in the ability to
          closely monitor a user's activity on the Web and take adverse action
          against this individual. Even when no action is taken, the
          possibility of surveillance alone can cause anxiety, discomfort, and
          behavioral changes such as inhibition and self-censorship, impacting
          individual autonomy and freedom of expression.
          </li>
          <li>
            <a data-cite=
            "credential-considerations#restrictions-of-free-expression">Exclusion
            and discrimination</a> of individuals who cannot, or do not want
            to, provide these credentials, prohibiting them from participation
            in services that would previously not require government-issued
            credentials, such as forums and social media platforms on the Web.
          </li>
        </ul>
        <h5>
          Mitigating unnecessary requests for government credentials
        </h5>
        <p>
          The outlined risks of government-issued digital credentials present a
          challenge that cannot be solved by a single participant in the
          ecosystem, and will require a broader policy discussion within
          individual sovereign nations about the risks and benefits of
          accessing online services through real-world credentials.
        </p>
        <p>
          It is desirable that a government that issues digital credentials
          also enact laws and regulations that clearly define how and for what
          purposes those credentials are able to be used. All parties involved
          in the exchange, whether they are legally obliged to do so or not,
          are advised to support any government [=verifier=] authentication
          schemes, if they exist. The support for (and integration of) verifier
          authentication schemes such as <a href=
          "https://github.com/eu-digital-identity-wallet/eudi-doc-architecture-and-reference-framework/blob/main/docs/annexes/annex-2/annex-2-high-level-requirements.md#a2327-topic-27---registration-of-pid-providers-providers-of-qeaas-pub-eaas-and-non-qualified-eaas-and-relying-parties">
          EUDI access and registration certificates</a> can mitigate risks of
          proliferation of unnecessary credential requests. However, the
          presence of such schemes is not guaranteed, which significantly
          increases the risk in a credential exchange.
        </p>
        <p>
          There are other practical steps that [=user agents=] implementing the
          Digital Credentials API can take to reduce risk, increase user
          understanding, and prevent certain types of harm:
        </p>
        <ul>
          <li>Only supporting protocols that enable selective disclosure and
          other techniques of data minimization can reduce the impact and
          likelihood of information leakage, and provide better context to
          users in permission and consent flows.
          </li>
          <li>Support for protocols that allow unlinkability mechanisms such as
          Zero-Knowledge Proofs can prevent [=verifier=]-based surveillance and
          potential discrimination, by hiding the [=issuer=].
          </li>
          <li>Offering useful context and a clearly understandable permission
          flow will help users make better decisions on whether or not to
          accept a credential exchange, which can reduce the viability of
          exchange requests that are made without a concrete user need.
          </li>
        </ul>
        <p>
          It is further critical that [=user agents=] design a permission
          experience that accounts for the lack of these mitigations, e.g., the
          exchange of personal information from government credentials without
          any [=verifier=] authentication scheme. It is recommended that a
          higher level of friction and clear user messaging that highlights the
          involved risk be applied to these types of exchanges.
        </p>
        <h4>
          Non-government-issued credentials
        </h4>
        <p>
          Non-government-issued credentials include all other digital
          documents, certificates, and attestations that are not
          government-issued and don't represent government-issued documents.
          This could include proof of employment, (non-government) education
          credentials, or cinema tickets. Notably, their exchange is likely
          less restricted by laws and regulations. While these documents often
          don't exhibit the same risks as government-issued credentials, they
          could also contain identifiable or sensitive information.
        </p>
        <h5>
          Risk of theft and leakage of non-government credentials
        </h5>
        <p>
          The impact and viability of credential theft and leakage of
          non-government credentials is largely based on the content of each
          individual credential type. In general, it could lead to loss of
          control and exposure of sensitive private information, as well as
          impersonation and data theft, which can increase the likelihood of
          further attacks on the affected individual.
        </p>
        <h5>
          Risk of proliferation of requests for non-government credentials
        </h5>
        <p>
          The flexibility and lack of regulation of non-government credentials
          carries potential for abuse for the purpose of cross-site tracking
          and linking identities through long-lived identifiers, such as email
          address or phone number. [=verifiers=] participating in a tracking
          scheme based on digital credentials could create user incentives to
          accept sharing identifier credentials across many sites ("loyalty
          cards" for the Web), without fully understanding the implications on
          their privacy.
        </p>
        <p>
          Even users unwilling to share their information in such a scheme
          could be affected by prompt fatigue and potentially risk exclusion
          from using these services.
        </p>
        <h5>
          Mitigating unnecessary requests for non-government credentials
        </h5>
        <p>
          For non-government-issued credentials, it is recommended that the
          [=user agent=] understand the requested credential format and its
          privacy attributes, and build a risk framework that informs the
          context that is shown to the user, as well as the amount of friction
          that is appropriate for each credential type. Protocols and formats
          involved in the exchange of these credentials are generally expected
          to support features such as selective disclosure and unlinkability,
          but these features might not always be appropriate or necessary in
          the exchange of information, especially when it concerns low-risk
          credentials such as cinema tickets.
        </p>
        <p>
          A [=user agent=] that recognizes the type of credential being
          requested is encouraged to customize its permission experience to
          best suit the requested credential and help users understand the
          consequences of sharing it.
        </p>
        <p>
          [=User agents=] cannot be expected to understand all credential
          requests. A [=user agent=] that does not recognize the type of
          credential being requested is advised to significantly increase user
          friction in their permission experience, and very clearly communicate
          the risks of sharing unknown credentials with websites to the user.
          Note that this could require integration between <a href=
          "#multiple-user-agents">different user agents</a> to apply
          appropriate levels of friction and transparency. For example, a
          browser might delegate knowledge about credential requests to the
          operating system, which might require digital wallets to register
          known credential types and reject an exchange request for an unknown
          credential type.
        </p>
        <p class="issue" data-number="100">
          The need to provide users with appropriate transparency conflicts
          with the desire to enable the ecosystem to develop new credential
          formats without explicit [=user agent=] buy-in.
        </p>
        <h5>
          Reporting abuse
        </h5>
        <p class="issue" data-number="267">
          Consider an interoperable abuse reporting system for verifiers making
          unnecessary and abusive requests.
        </p>
      </section>
      <section>
        <!--
        // MARK: Fingerprinting and Data Leakage
        -->
        <h3>
          Fingerprinting and Data Leakage
        </h3>
        <h4>
          Browser fingerprinting
        </h4>
        <p>
          While the API ensures that no user data is ever shared without a
          permission prompt (see [[[#user-permission-and-transparency]]]), the
          longevity and uniqueness of real-world identifiers that are likely to
          be returned by the Digital Credentials API make it a potential target
          for trackers and fingerprinters.
        </p>
        <p>
          Even with selective disclosure, attackers might combine data from a
          digital credential (such as the user's age, or the credential
          [=issuer=], timestamps, see [[[#leaking-incidental-data]]]) to
          reidentify and/or fingerprint users.
        </p>
        <p>
          This attack might be harder for third-party attackers (such as
          scripts embedded on the [=verifier=]'s pages but not actively
          collaborating with them for the purpose of tracking) because response
          encryption is mandatory and responses should be decrypted on the
          [=verifier=]'s server. The [=verifier=] could thus ensure not to
          reflect back decrypted information to client-side JavaScript. Not all
          [=verifiers=] will choose to do so, however.
        </p>
        <h4 id="leaking-incidental-data">
          Leaking incidental data with credential presentations
        </h4>
        <p>
          To ensure authenticity of a credential, its presentation to
          [=verifiers=] generally includes more information than the content
          the [=verifier=] is requesting access to. It will usually contain at
          least a signature of the [=issuer=] and the digital wallet, and
          potentially other metadata.
        </p>
        <p>
          This additional information could be used to reidentify and
          fingerprint users, which is especially relevant when an otherwise
          unlinkable presentation is made.
        </p>
        <p>
          While the Digital Credentials API does not control the content of a
          credential response, [=user agents=] can help protect users against
          this type of tracking through clearly highlighting which information
          likely gets shared with the [=verifier=] beyond what was requested,
          and, more broadly, by identifying and blocking fingerprinting through
          the API by [=verifiers=].
        </p>
        <h4>
          Revealing device properties through protocol availability
        </h4>
        <p>
          The Digital Credentials API exposes information about which [=digital
          credential/presentation protocol|presentation=] and [=digital
          credential/issuance protocol|issuance=] protocols are supported by
          the [=user agent=] through
          {{DigitalCredential/userAgentAllowsProtocol()}}. It mitigates browser
          fingerprinting and revealing information about the user's device
          configuration by not customizing its response based on, for example,
          which digital wallet applications are installed on a user's device.
          The returned information is thus, at best, equivalent to a [=user
          agent=] version.
        </p>
        <h4>
          Avoiding leaks of credential availability
        </h4>
        <p>
          The Digital Credentials API does not enable sites to learn whether a
          credential is available without first going through a <a href=
          "#user-permission-and-transparency">user permission flow</a>.
          Revealing the presence of credentials would be a risk to user
          privacy, as the presence of a credential is personal information that
          the user might not have preferred to share with the site, and, in
          combination with other signals, could be used to identify the user
          without their permission. It is also a risk to free expression, as
          websites might increasingly start to demand the presentation of these
          credentials from the user in order to access services, excluding
          individuals who are unwilling to present credentials.
        </p>
      </section>
      <section id="user-permission-and-transparency">
        <!--
        // MARK: User Permission and Transparency
        -->
        <h3>
          User Permission and Transparency
        </h3>
        <p class="issue" title="Work in progress"></p>
        <p>
          The Digital Credentials API enables the sharing of highly personal,
          sensitive, and at-risk user information with websites via
          credentials, potentially granting the ability to track users online
          and offline, through permanent, unique, irrevocable, cross-context
          identifiers. It also reveals parts of the user's browsing activity as
          well as their intent to identify to specific websites and/or digital
          wallets. One crucial responsibility of the [=user agent=] in a
          credential request is to gather permission from the user to proceed
          with the exchange of information.
        </p>
        <p>
          Important context details that are needed for a user to make an
          informed decision about proceeding with a credential exchange include
          the following:
        </p>
        <ul>
          <li>The origin of the [=verifier=] that requests the credential.
          </li>
          <li>The information that is being requested, or that would be
          revealed by responding to the request.
          </li>
          <li>Whether presenting this information will enable tracking.
          </li>
          <li>Which digital wallets can be used to fulfill the credential
          request.
          </li>
          <li>Which credential would be used to share the requested
          information.
          </li>
        </ul>
        <p>
          It is advised that [=user agents=] in their implementation ensure
          that the details listed are fully disclosed to the user before an
          exchange of any user-related information occurs.
        </p>
        <p class="issue" data-number="252">
          Should these be normative in the spec?
        </p>
        <p class="issue" data-number="44">
          Should the API be designed so the site can provide in-context
          explanations?
        </p>
        <h4>
          Handling multiple credential requests
        </h4>
        <p class="issue" data-number="286">
          We need to describe concerns, tradeoffs and possible mitigations of
          handling multiple requests and responses for credential presentation.
        </p>
        <h4 id="multiple-user-agents">
          Integrating Multiple User Agents
        </h4>
        <p>
          Depending on the technical architecture of a user's system, it is
          likely that the definition of a "[=user agent=]" will include
          multiple cooperating layers of the software stack, such as a browser
          and the operating system. The greatest priority for these layers has
          to be a safe and well-informed user permission experience. As such,
          integration can be vital for user safety. Some layers may hold
          information that is inaccessible by other layers, such as the
          availability of a user's credentials. Overprompting or prompting
          without sufficient context could lead to (exploitable) confusion and
          prompt blindness.
        </p>
        <p>
          For this reason, [=user agents=] prompting for permission are
          encouraged to integrate software layers for an ideal user experience,
          if they consider it safe to do so. This could happen, for example, if
          a browser trusts the API contract of an operating system to show an
          appropriate prompt, and thus does not show a prompt itself.
        </p>
        <h4>
          Permission Prior to Wallet Selection
        </h4>
        <p>
          As part of the user permission flow, the [=user agent=] needs to
          ensure that users retain the power to choose whether to forward a
          credential request to a digital wallet, and which digital wallet to
          select. This is due to the information disclosure that happens as
          part of the request, and the ability of digital wallets to retain or
          share this information at the time of the request.
        </p>
        <h4>
          Permission vs. Consent
        </h4>
        <p>
          The permission mediated by the [=user agent=] is not consent, which
          has specific legal definitions that can vary among different legal
          and regulatory environments and may need to be collected by the
          digital wallet before sharing information with the [=verifier=], or
          by the [=verifier=] itself before initiating the request. With
          frameworks and regulations for obtaining consent still being
          developed, this API aims to enable the exchange of the necessary
          information, which could include the following:
        </p>
        <ul>
          <li>The privacy policy of the [=verifier=] receiving the credential.
          </li>
          <li>The purpose for which the [=verifier=] is requesting the
          information.
          </li>
          <li>What the information will be used for.
          </li>
          <li>How the information will be shared or retained.
          </li>
          <li>Any evaluations and attestations of this information, if
          available.
          </li>
          <li>Assertions of the [=verifier=]'s legitimacy and registration for
          accessing the credential, such as <a href=
          "https://github.com/eu-digital-identity-wallet/eudi-doc-architecture-and-reference-framework/blob/main/docs/annexes/annex-2/annex-2-high-level-requirements.md#a2327-topic-27---registration-of-pid-providers-providers-of-qeaas-pub-eaas-and-non-qualified-eaas-and-relying-parties">
            EUDI access and registration certificates</a>.
          </li>
        </ul>
        <p>
          As more of this information becomes available in a structured format,
          we expect [=user agents=] and this specification to leverage it to
          improve the user permission experience as well.
        </p>
      </section>
    </section>
    <section>
      <!--
      // MARK: Accessibility Considerations
      -->
      <h2>
        Accessibility Considerations
      </h2>
      <p>
        Implementers need to consider accessibility when designing [=credential
        choosers=] specifically for this API. The content of modal dialogs
        presented during [=digital credential/issuance request|issuance=] or
        [=digital credential/presentation requests|presentation=], which can
        include text, QR codes, and other visual media, SHOULD be labelled and
        exposed to assistive technologies.
      </p>
      <p>
        Interactive elements, particularly those that allow the user to
        continue or abort [=digital credential/issuance request|issuance=] or
        [=digital credential/presentation requests|presentation=] requests,
        MUST be operable in a device-independent manner.
      </p>
    </section>
    <section class="prefer-full-spec-title" id="index"></section>
    <section id="idl-index"></section>
    <section id="conformance"></section>
    <h2 class="appendix">
      Acknowledgements
    </h2>
    <p>
      Some of the Editors would like to thank the following individuals for
      their feedback and contributions to this specification: Christian Bormann
      (SPRIND), John Bradley (Yubico), Rick Byers (Google), Brian Campbell
      (Ping Identity), Lee Campbell (Google), Nick Doty (CDT), Heather Flanagan
      (Spherical Cow Consulting), Ryan Galluzzo (NIST), Joseph Heenan
      (Authlete), Dominique Hazael-Massieux (W3C), Bjorn Hjelm (Yubico), Johann
      Hofmann (Google), Mike Jones (Self-Issued Consulting), Tobias Looker
      (MATTR), Matthew Miller (Cisco), Theresa O'Connor (Apple Inc.), Simone
      Onofri (W3C), Helen Qin (Google), Wendy Seltzer (Invited Expert), Manu
      Sporny (Digital Bazaar), Orie Steele (Transmute), Ted Thibodeau Jr
      (OpenLink Software), David Waite (Ping Identity), and Kristina Yasuda
      (SPRIND).
    </p>
  </body>
</html>
